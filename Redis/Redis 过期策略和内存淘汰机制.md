# Redis 过期策略和内存淘汰机制

众所周知，redis 是一个基于内存的，能够持久化到硬盘的缓存数据库，所以 redis 缓存服务器会配置较高的内存资源

一般而言，缓存总量小于数据总量，但如果对缓存数据不管不顾，内存资源总会有耗尽的时候，而为了节约成本，不能一直增加服务器的内存。因此在有限的资源下，为了支撑更多的业务，就必须将访问频率不高的缓存删掉，为新的缓存腾出内存空间

Redis 主要通过两种方式相互配合实现 key 的清理，即：过期策略和内存淘汰机制

## 过期策略

Redis 通过 `Expire` 命令设置 `key` 的过期时间，设置过期时间后， key 会被自动删除。通常称带有过期时间的 key 为易失的 (volatile)；过期时间的 key，可以调用 `EXPIPE` 重新设置

**过期时间计算**
`key` 的过期时间以绝对 `Unix` 时间戳的方式存储，也就是无论 Redis 是否进行，过期时间都会流逝。即要求服务器的时间必须准确，否则但两个时间相差较多的机器之间移动 RDB 文件，那么可能会出现所有的 key 在加载的时候都过期。

测试：运行的 Redis 会不停检查服务器的时间，如果设置一个带有 1k 秒过期时间的 key，然后把服务器的时间向前调 2k 秒，那么这个 key 就会立刻过期，而不是等待 1k 秒后过期

### 淘汰过期 key 方式

**被动方式**

在用户访问某个 key 的时候，Redis 会检测 key 是否过期，如果没有过期，则返回给用户；过期则删除 key。也就是等 key 被访问才会知道是否过期，这种方式对于那些永远不会再次访问的 key 没有效果，所以 Redis 还会周期性主动随机检测一部分被设置过期时间的 key，将已经过期的 key 从 key 空间删除

**主动方式**

Redis 每秒会执行10次以下操作：
1. 从带有过期时间的 key 集合中随机选 20 进行检查
2. 删除所有过期的 key
3. 如果里面超过 25% 的 key 过期，立刻继续执行步骤 1

一种狭义概率算法，假设选出来的样本 key 代表整个 key 空间，会一直执行过期检查直到 key 的比例降到 25% 以下；意味着在任意时刻已经过期但还占用内存 key 的数量，最多等于每秒最多写操作的 1/4

## 内存淘汰机制

Redis 的内存一般会根据 "八二原理" 进行配置，即80%的请求访问了20%的数据，将 Redis 内存大小设置为数据总量的20%。当然，对于不同的业务场景会有不一样的配置

当 redis 节点分配的内存使用到达最大值，Redis 会启动内存淘汰策略，Redis 4.0 之前主要是以下六种策略：
- noenviction：不清除数据，只是返回错误，这样会导致浪费掉更多的内存，对大多数写命令（DEL 命令和其他的少数命令例外）
- allkeys-lru：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，以供新数据使用
- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰，以供新数据使用
- allkeys-random：从所有数据集（server.db[i].dict）中任意选择数据淘汰，以供新数据使用
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰，以供新数据使用
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，以供新数据使用

Redis 4.0 新增了两种 LFU 淘汰策略:
- allkeys-lfu，淘汰整个键值中最少使用的键值，这也就是我们常说的LRU算法。
- volatile-lfu，淘汰所有设置了过期时间的键值中最少使用的键值。

> LRU（Least Recently Used，最近最少使用），根据最近被使用的时间，离当前最远的数据优先被淘汰；在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉
> LFU（Least Frequently Used，最不经常使用），在一段时间内，缓存数据被使用次数最少的会被淘汰；根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来

普适经验规则：
- 如果期望用户请求呈现幂律分布(power-law distribution)，也就是，期望一部分子集元素被访问得远比其他元素多时，可以使用allkeys-lru策略。在你不确定时这是一个好的选择
- 如果期望是循环周期的访问，所有的键被连续扫描，或者期望请求符合平均分布(每个元素以相同的概率被访问)，可以使用allkeys-random策略
- 如果你期望能让 Redis 通过使用你创建缓存对象的时候设置的TTL值，确定哪些对象应该是较好的清除候选项，可以使用volatile-ttl策略
- 当你想使用单个Redis实例来实现缓存和持久化一些键，allkeys-lru和volatile-random策略会很有用，但通常最好是运行两个Redis实例来解决这个问题

## 参考
[1] [EXPIRE key seconds](https://www.redis.com.cn/commands/expire.html)
[2] [使用Redis作为LRU缓存](https://www.redis.com.cn/topics/lru-cache.html)